# -*- coding: utf-8 -*-
"""python_10_기본문법정리.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1QTEMZSmA0gJuo9NOJZ7XhpIa54bI4ohZ

주석
"""

print("hello")

# 한 줄 주석 처리

# print("mulcam")

# 여러 줄 주석처리

'''
아이고 ... 이렇게 시간이 안가냐?
'''
print("이해했죠?  1111 예")

"""원시 데이터 타입
- integer, float, string, boolean
"""

num_int = 30
print(num_int)
print(type(num_int))

num = 30.5
print(num)
print(type(num))

더하기 = 30 + 45.5
print(더하기)
print(type(더하기))

내_이름 = "닥터윌"
print(내_이름)
print(type(내_이름))

참거짓 = True and False
print(참거짓)
print(type(참거짓))

"""파이선의 연산 - 사칙연산
- 두 개의 변수를 만들기
"""

x = 6
y = 3

result = x+y
print(result)

z = 0

print(x-y)
print(x*y)
print(x/y) # 실수형으로 변환
print(type(x/y))

# print(x/z)
# ZeroDivisionError: division by zero

print(x // y)  # 몫

print(x%y) # 나머지

x = 2
result = x ** 4

print(result)

"""조건 연산자"""

x = 418
y = 430

print(x == y)
print(x != y)
print(x > y)
print(x < y)
print(x >= y)
print(x <= y)

# 사용자에게 입력받기

입력 = input("임의의 숫자를 입력하세요: ") # 문자를 입력 받음
print(입력)
print(type(입력)) # 형태 변환 필요함
입력_형변환 = int(입력)
print(입력_형변환)
print(type(입력_형변환))

# 입력값은 문자 >> 형변환 해준다
x = int(input("아무 숫자나 입력해 주세요: ")) # 문자 >> 숫자
y = int(input("아무 숫자나 입력해 주세요: ")) # 문자 >> 숫자

print(x, y)
print(type(x))
print(type(y))

result = x + y
print(result)

# 논리 연산자

True or False

(3>2) or (2>3)

"""String - 1. 덧셈, 곱셈 연산자, 인덱싱, 슬라이싱"""

a = "boy"
b = "loves"
c = "girl"

letter = a + " " + b + " " + c + " forever"
print(letter)

x = "야이야이야...사랑한다고"
lyrics = x * 5
print(lyrics)
print(len(lyrics))

print(lyrics[-65])
print(lyrics[0])

# indexing
print(x[0])
print(x[-5:])
print(x[:5])

이메일 = 'drwill@naver.com'

# 문제 : drwill 추출할 것
print(이메일[:5])
# 문제: 어느 회사 이메일을 쓰나요? naver
print(이메일[-9:-4])

# 전화번호 추출
# 주소

tel = '010-5123-7890'
주소 = '서울시 강남구 대치3동 멀티캠퍼스 옆 PC방'

# 5123 추출해 보세요
print(tel[4:8])

# 구, 동 추출
print(주소[4:7])
print(주소[8:12])

전처리전_주소 = "  서울시 강남구 선릉역 1번 출구     "
print(전처리전_주소)

print(전처리전_주소.strip())

전처리한주소 = 전처리전_주소.strip()
print(전처리한주소)
# 이 주소로 갈려면 지하철 무슨 역에서 내려야 하나요?
print(전처리한주소[-9:-6])

전처리한주소.find("역")

index = 전처리한주소.find("역")
print(index, 전처리한주소[index-2:index+1])

print(전처리한주소[0:8:2])

print(전처리한주소)

# index 와 find 차이
'''
1. index()
- 문자열, 리스트, 튜플 다 사용 가능
- 찾고자 하는 값이 존재하면 그 위치의 index 반환
- 단, 찾는 값이 없으면 >> 에러 발생(value error)

2. find 문자열에 사용
- 주로 문자열 사용
- 찾고자 하는 값이 존재하면 그 위치의 index 반환
- 찾고자 하는 값이 없으면 >> '-1' 반환
- 문자열 검색시, 예외처리가 필요없다는 장점

'''

전처리한주소.index('역')

전처리한주소.find('역')

# 전처리한주소.index('입구')
# ValueError: substring not found
# 해당되는 문자가 없으면 value error 발생

전처리한주소.find('입구')
# 에러는 안 내고, '-1'을 반환

# 문장 중 문자열이이 몇 번째인지 세는 함수
# .count() 메소드
text = "나는 파이썬 전처리가 너무 재미있어요. 이렇게 재미있는 것을 이제 알다니. 너무 재미있다"
찾는문자 = '재미'

text.count(찾는문자)

"""문자열 수정"""

greeting = "Hello, everyone"
# greeting[0] = "h"

# print(greeting)
# TypeError: 'str' object does not support item assignment

'h' + greeting[1:]

new_greeting = 'h' + greeting[1:]
print(new_greeting)

# 대문자로 전환, 소문자로 전환

greeting.lower() # lower() 소문자로 변환하는 메소드

greeting.upper() # upper() 대문자로 변환하는 메소드

greeting_upper = greeting.upper()
print(greeting_upper)
print(greeting_upper.title())

# replace (대체하다) (꼭 암기)

print(greeting_upper)
greeting_upper.replace("HELLO","방가르~")

# split(sep='') '' 기준으로 나누다 sep: separate
# >> sep 기준으로 분리한 후, 리스트(list)로 반환

greeting_replace = greeting_upper.replace("HELLO","방가르~")

greeting_replace.split(sep=',')

words = greeting_replace.split(sep=',')
print(words)
print(type(words))

"""List"""

from collections.abc import Sequence
#  시퀀스: 데이터에 순서가 있음 (인덱싱, 슬라이싱)

my_num = 100
my_string = "hello"
my_list = [1,2,3]

isinstance(my_list, Sequence)
# 주어진 객체가 시퀀스인지 확인하는 코드

print(isinstance(my_num, Sequence))
print(isinstance(my_string, Sequence))
print(isinstance(my_list, Sequence))

my_string[3]

"""indexing과 slicing"""

a = [400,300,200]
print(a[-2])

a[:-1]

"""중첩리스트"""

my_list = [1,2,["variety","is","the","spice","of","life"], 4,5]
print(my_list)

my_list[2]

my_list[2][3:]

"""List의 주요 메서드"""

# append 와 extend

# append
# list 끝에 새로운 값 입력
# list 나 다른 자료형 요소 추가 가능
# >> 예를 들어, 추가된 리스트는 리스트의 한 요소가 되어 버림
txt = ["I","like"]
고백 = txt.append("your smile")
print(고백)

txt

my_list = [1,2,3]
my_list.append(4) # 숫자 값 하나
print(my_list)

my_list.append([5,6])
print(my_list)

# extend
# 리스트에 다른 리스트의 모든 요소 추가 >> 리스트 확장
# 다른 리스트의 요소를 그대로 추가해서 기존 리스트를 확장
txt = ["Do","you"]
txt.extend(["like","coffee","?"])
txt

my_list = [1,2,3]
another_list = [4,5,6]
my_list.extend(another_list)
print(my_list)

# insert

nums = [0,1,3,4]
nums.insert(2, 2)
nums

letter = ["You","are","my","love"]
letter[3] = "everything"  # indexing 활용, 값 변경
print(letter)

letter = ["You","are","my","love"]
letter.remove("are")
print(letter)

nums = [3,1,20,5,6]
nums.sort()
print(nums)

nums = [3,1,20,5,6]
nums.sort(reverse=True)
# 정렬(역순 정렬 옵션 사용) >> 내림차순
# default : 오름차순
print(nums)

"""Tuple_튜플"""

my_tuple = ("하이", 1, 3.14)
print(my_tuple)
print(type(my_tuple))

my_tuple = ("Hi", [1,2,3], (3.14, 1.35, 4.26))
# tuple 순서가 있음(인덱싱,슬라이싱)

print(my_tuple[2])
print(my_tuple[2][1])

my_list = ["Hi", 1, 3.14]
my_list[0] = 0
# list 값 변경(indexing 활용)
print(my_list)

del my_list[2] # list에서 특정 값 제거(indexing 활용)

print(my_list)

my_tuple= ("Hi", 1, 3.14)
# my_tuple[0] = 0
# TypeError: 'tuple' object does not support item assignment
# >> tuple 은 immutable 변경 불가능
# del my_tuple[0]
# TypeError: 'tuple' object doesn't support item deletion
# >> tuple 은 immutable 변경 불가능

my_tuple = ("Love", "Love","Love", "Love", "Hate", "Love", "Love")
print(my_tuple)
print(my_tuple.count("Love"))
print(my_tuple.index("Hate")) # 특정 값의 위치 정보(index) 반환

"""딕셔너리_Dictionary"""

my_dict = {'name' : 'will',
            'age' : 20,
            'shopping': [1,2,3]
            }

print(my_dict)
print(type(my_dict))

your_dict = \
{'name' : 'will',
 'age' : 20,
 'shopping': [1,2,3]
            }

# \ : 개행문자

print(my_dict)

print(my_dict['age']) # indexing

my_dict['county'] = '대한민국' # 새로운 데이터 추가(key 생성)
print(my_dict)

# 값 변경
my_dict['shopping'] = '가방'
print(my_dict)

# del my_dict['shoping']
# KeyError: 'shoping'
print(my_dict)

print(my_dict.keys())

list(my_dict.keys())

key_list = list(my_dict.keys())
print(key_list)

print(my_dict.values())

value_list = list(my_dict.values())
print(value_list)

print(my_dict.items())

list(my_dict.items())

item_list = list(my_dict.items())

for k, v in item_list:
    print(k, v)

"""조건문"""

a = 31
b = 31

if a > b :
    print("a가 b보다 크거나 같다")
elif a == b:
    print("a가 b와 값이 같다")
else:
    print("a가 b보다 작다")

txt = "I don't care, please let me go"

if "let" in txt:
    print("let 글자 존재")
else:
    print("let 글자 존재하지 않음")

"""반복문"""

# 반복문 사용 이유: 효율성!
# for loop

range(10)
print(list(range(10)))

for i in range(10):
    print(i)

for i in range(10):
    print(str(i) + " 번째 Hi!!")

for i in range(1,11):
    print(str(i) + " 번째 Hi!!")

my_list = [10,20,30]

for i in my_list:
    print(i)

my_list = [10,20,30]

for i in my_list:
    print(i)

else:
    print("반복문 완전 종료~")

# enumerate
# 반복 가능한(iterable) 객체 (리스트, 튜플, 문자열) 입력으로 받아서
# 인덱스(index)와 해당 요소를 포함하는 내용 >> 반복문

'''
for index, value in enumerate(반복가능한 객체):
    처리할 작업 코드
'''

fruits = ['사과', '배', '체리','딸기']

for i, fruit in enumerate(fruits):
    print(f'인덱스{i}에 있는 과일: {fruit}')

# f string : format 문자열

# 소화가 잘되는 과제
# 한국-태국전 라인업 보시고 리스트 생성후, enumerate 사용해서
# 한국 축구대표팀 라인업 명단을 만들어 보세요.

team_korea = ['조현우', '김영권','김민재','백승호','손흥민','이강인','정우영']

for i, player in enumerate(team_korea):
    print(f'국가대표 축구 대표팀 {i+1}번 선수는 {player}입니다')

num_lists = [10,20,30]

for i, num in enumerate(num_lists):
    print(i+1, num)

"""zip 함수
- 두 개 이사이의 반복 가능한(iterable) 객체(리스트, 튜플, 문자열)를 [병렬]로 묶어주는 함수
- 각각의 반복 가능한 객체에서 같은 index 요소들을 묶어서 튜플로 만들어 주는 역할


"""

'''
zip(반복가능한 객체1, 반복가능한 객체 2)
'''

names = ["양진욱","박민석","예동완","김지우","박소현","김선규","성수린"]
ages = [20,21,22,23,24,25,26]
heights = [177,178,179,180,181,182,183]

for name, age, height in zip(names, ages, heights):
    print(f'{name}의 나이는{age}살이고 키는{height}cm 입니다')

# 실생활 응용 문제

# 단가
prices = [1.2, 3.4, 2.5]

# 판매량
total_sales = [100,80,90]

for sales, price in zip(total_sales, prices):
    revenue = sales * price
    print(f'매출액: {revenue}')

"""while loop"""

for i in range(3):
    print(i)

# for문 차이

'''
while True:
    print("무한반복 지옥에 빠짐")


    # 반복문을 멈출려면 >> 정지조건이 있어야 함
'''

i = 1

while i <= 10:  # 정지조건
    print(i)
    i += 1   # i = i+1

i = 1

while i <= 10:  # 정지조건
    print(str(i) + " 번째 손님, 방가워요~")
    i += 1   # i = i+1

"""사용자 정의 함수"""

'''
def 함수명(매개변수1, 매개변수2....):
    # 처리할 코드 입력
    return
'''

def add(num1, num2):
    result = num1 + num2
    return result

print(add(20,30))

a = 20
b = 30

temp = add(a,b) # 함수의 객체
print(temp)

def addition(num1, num2):
    result = num1 + num2
    print(result)

a = 20
b = 40

print(addition(a,b))

def 더하기(num1, num2, num3=None, num4=0):
    result = num1 + num2
    print(result)

a = 20
b = 40

print(더하기(a,b))

"""질의응답"""

# “10 단위로 커지는 사이즈”라는 조건을 충족하기 위해 input에 입력 가능한 숫자를 제한할 수 있는 방법이 있나요?

def Input_ten_unit(number):
    return number % 10 == 0

while True:
    try:
        size = int(input("10단위로 증가되게 입력해 주세요: "))
        if not Input_ten_unit(size):
            print("유효한 입력값이 아니예요. 다시 입력해 주세요")
            continue

        if size <=150:
            print("아동용")
        elif size >= 190:
            print("맞춤옷")
        else:
            print("성인용")
        break
    except ValueError:
        print("유효한 값을 넣어주세요.")

while True:
    size = int(input("10단위로 나오게 사이즈 입력해 주세요"))
    if size < 100:
      print("100이상의 값 입력하기")
      continue
    if size % 10 != 0:
      print("10의 배수 사이즈만")
      continue
    if size <= 150:
        print("아동용")
    elif size >= 190:
        print("맞춤복")
    else:
        print("성인복")
    break

while True:
    size = int(input())
    if size % 10 != 0:
        print("숫자는 10의 단위로 입력하세요!")
        continue

    if size <= 150:
        print('아동용')
    elif size>= 190:
        print('맞춤옷')
    else:
        print('성인용')
    break

